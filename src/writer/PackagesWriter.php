<?php
declare(strict_types = 1);

namespace tools\packageBuilder\writer;

use InvalidArgumentException;
use tools\packageBuilder\util\PackageContainer;

class PackagesWriter {

    private const HEADER = '<?php' . PHP_EOL . 'declare(strict_types = 1);' . PHP_EOL;

    /**
     * @var WriterOptions
     */
    private $options;

    /** @var array $dryRunResult */
    private $dryRunResult = [];

    public function __construct(WriterOptions $options) {
        $this->options = $options;
    }

    /**
     * @return array
     */
    public function getDryRunResult(): array {
        return $this->dryRunResult;
    }

    /**
     * @param array $dryRunResult
     *
     * @return $this
     */
    public function setDryRunResult(array $dryRunResult): self {
        $this->dryRunResult = $dryRunResult;

        return $this;
    }

    /**
     * @param array $dryRunResult
     *
     * @return $this
     */
    public function addDryRunResult(array $dryRunResult): self {
        $this->dryRunResult[] = $dryRunResult;

        return $this;
    }

    /**
     * @return WriterOptions
     */
    public function getOptions(): WriterOptions {
        return $this->options;
    }

    /**
     * Schreibt anhand der Ã¼bergebenen package.php Dateien eine packages.php Datei
     *
     * @param string $targetpath
     * @param array $packages
     *
     * @return null|string
     * @throws \Exception
     */
    public function writePackagesFile(
        string $targetpath,
        PackageContainer $packageContainer
    ): ?string {
        if (!is_dir($targetpath)) {
            throw new InvalidArgumentException('Path '. $targetpath . ' is not a directory!');
        }
        if ($packageContainer->isEmpty()) {
            throw new InvalidArgumentException('Expected non empty container!');
        }
        if ('/' !== substr($targetpath, -1)) {
            $targetpath .= '/';
        }
        $packagesFilePath = $targetpath . 'packages.php';
        $content = $this->createContent($targetpath, $packageContainer);
        if ($this->getOptions()->isDryRun()) {
            $result[$packagesFilePath] = $content;
            $this->setDryRunResult($result);
        } else {
            if (file_exists($packagesFilePath) && !$this->getOptions()->doOverwriteExisting()) {
                echo 'Package file ' . $packagesFilePath . ' already exists. '
                    . 'It could not be overwrite. Aborting...' . PHP_EOL;
                return null;
            }
            if (false === ($filehandler = fopen($packagesFilePath, 'w'))) {
                throw new \Exception('Could not open ' . $packagesFilePath);
            }
            fwrite($filehandler, $content);
            fclose($filehandler);
        }

        return $packagesFilePath;
    }

    private function createLine(string $namespace, string $targetpath, string $path): string {
        $relativePath = preg_replace(
            sprintf('#(.*%s)#', $targetpath),
            '',
            $path
        );

        return sprintf(
            '    %s__DIR__ . \'/%s\',%s',
            (null === $namespace || '' === $namespace) ? '' : '\'' . $namespace . '\' => ',
            $relativePath,
            PHP_EOL
        );
    }

    private function createContent(string $targetpath, PackageContainer $packages): string {
        $packages->sortPackages();
        $content = self::HEADER . PHP_EOL;
        if ($this->getOptions()->isWithAutogeneratedTs()) {
            $content .= $this->getOptions()->getAutogeneratedTimestampInfoString() . PHP_EOL;
        }
        $content .= 'return [' . PHP_EOL;
        foreach ($packages as $namespace => $path) {
            $content .= $this->createLine($namespace, $targetpath, $path);
        }
        $content .= '];';

        return $content;
    }
}